{
  "name": "Ep128emu",
  "tagline": "IstvanV's great Enterprise-128 emulator imported to github",
  "body": "ep128emu 2.0.9.1\r\n================\r\n\r\nep128emu is an open source, portable emulator of the Enterprise 128,\r\nZX Spectrum 48/128, and Amstrad CPC 464/664/6128 computers, written in\r\nC++, and supporting Windows and POSIX platforms (32 bit Windows, 32 and\r\n64 bit Linux, and MacOS X have been tested).\r\nIt implements accurate, high quality hardware emulation, however, the\r\nsystem requirements are higher than that of most other emulators.\r\n\r\nFeatures\r\n========\r\n\r\nGeneral\r\n-------\r\n\r\n  * graphical user interface using the FLTK library\r\n  * software (FLTK based) or OpenGL video, with resizable emulator\r\n    window, fullscreen mode, brightness, contrast, gamma, hue, and color\r\n    saturation control; additional features in OpenGL mode only: single\r\n    or double buffered (with synchronization to vertical refresh) mode,\r\n    linear texture filtering, resampling video output to the monitor\r\n    refresh rate, and some display effects: motion blur, scanline\r\n    shading, and (if OpenGL 2.0 shaders are available) PAL TV emulation\r\n  * real time audio output uses the PortAudio library (v18 or v19), with\r\n    support for many native audio APIs (MME/DirectSound/WDM-KS/WASAPI on\r\n    Windows, OSS/ALSA/JACK on Linux, and CoreAudio on MacOS X); high\r\n    quality sample rate conversion with low aliasing; volume control,\r\n    two first order highpass filters with configurable cutoff frequency,\r\n    and an optional parametric equalizer can be applied to the audio\r\n    signal\r\n  * recording audio output to a WAV format sound file\r\n  * recording video and sound output to an AVI format video file, with\r\n    768x576 RLE8 or 384x288 uncompressed YV12 video at 24 to 60 frames\r\n    per second, and 48000 Hz stereo 16-bit PCM audio\r\n  * saving screenshots as 768x576 8-bit RLE compressed BMP files\r\n  * saving and loading snapshots of the state of the emulated machine\r\n  * demo recording (snapshot combined with stream of keyboard events\r\n    which can be played back with accurate timing)\r\n  * GUI tape editor utility for copying Enterprise files from/to\r\n    ep128emu tape images\r\n  * GUI debugger with support for breakpoints/watchpoints, viewing the\r\n    current state of CPU registers and memory paging, displaying memory\r\n    dump and searching for a pattern of bytes, and disassembler with\r\n    support for all documented and some undocumented Z80 opcodes.\r\n    A simple monitor is also included, with commands like assemble,\r\n    disassemble (also to file), trace, memory and I/O port dump and\r\n    modify, printing and changing CPU registers, memory compare, copy,\r\n    fill, search, load and save, and more.\r\n    For most operations, addresses can be 16 bit CPU (affected by\r\n    current paging) or 22 bit physical (all ROM and RAM data can be\r\n    accessed, regardless of memory paging) addresses. Watchpoints can\r\n    also be set on I/O ports and physical addresses.\r\n    The debugger supports scripting in the Lua language, to allow for\r\n    advanced uses like breakpoints with custom defined, complex set of\r\n    conditions.\r\n  * configurable keyboard map for the emulated machine; it is also\r\n    possible to use external game controller devices like joysticks and\r\n    gamepads\r\n\r\nEnterprise emulation\r\n--------------------\r\n\r\n  * instruction based emulation of the Z80 CPU, supports all documented\r\n    and some undocumented opcodes, and memory wait states (including\r\n    synchronization with the NICK chip when accessing video memory)\r\n  * RAM size can be set in 16 kilobyte steps in the range 64 to 3712\r\n  * ROM can be loaded from external image files to segments 0 to 7,\r\n    16 to 19 (decimal), 32 to 35, 48 to 51, and 64 to 67\r\n  * using external configuration files, it is also possible to define\r\n    any memory configuration without the above limitations\r\n  * NICK chip emulation, supporting all documented and undocumented\r\n    video modes\r\n  * DAVE emulation, including timers, interrupts, external ports for\r\n    tape and keyboard/joystick, memory paging, and sound output (all\r\n    effects are supported, and the polynomial counters generate the same\r\n    pseudo-random \"noise\" pattern as on the real machine)\r\n  * tape emulation with playback, recording, and setting tape position;\r\n    markers can be created for quick positioning to specific tape\r\n    locations (useful for tapes with multiple files); uses custom file\r\n    format which is PCM audio data with 1 to 8 bits of sample resolution\r\n    and variable sample rate, and header including the table of markers;\r\n    there is also limited (read only) support for EPTE format tape\r\n    files, as well as read-write (although without markers) support for\r\n    sound files like WAV, AIFF, etc.\r\n  * WD177x (floppy drive controller) emulation for EXDOS\r\n  * IDE hard disk emulation; supports up to 4 2 GB disks, image files\r\n    can be in raw or VHD format\r\n  * optional extension ROM (epfileio.rom) that implements a FILE: device\r\n    for direct access to files on the host system in a single user\r\n    selectable directory\r\n  * Spectrum emulator card emulation\r\n  * real time clock (at ports 7E, 7F)\r\n  * external 4-channel 8-bit DAC at ports F0 to F3\r\n\r\nSpectrum emulation\r\n------------------\r\n\r\n  * instruction based emulation of the Z80 CPU, supports all documented\r\n    and undocumented opcodes, and cycle accurate synchronization with\r\n    the ULA chip when accessing video memory and I/O ports\r\n  * RAM size can be 16, 48, or 128 kilobytes\r\n  * ROM can be loaded from external image files\r\n  * ULA, AY-3-8912, keyboard, and Kempston joystick emulation\r\n  * tape emulation with playback, recording, and setting tape position;\r\n    markers can be created for quick positioning to specific tape\r\n    locations (useful for tapes with multiple files); uses custom file\r\n    format which is PCM audio data with 1 to 8 bits of sample resolution\r\n    and variable sample rate, and header including the table of markers;\r\n    there is also read-write (although without markers) support for\r\n    sound files like WAV, AIFF, etc.\r\n  * Spectrum tape files in .tap format can be used as tape images for\r\n    read-only hardware level tape emulation, or loaded directly to\r\n    memory if the \"Enable virtual file I/O\" option is checked in the\r\n    machine configuration\r\n  * it is also possible to load .tzx format tape images, although the\r\n    support for these is not complete yet\r\n  * loading SNA and Z80 format snapshot files created by other emulators\r\n    is supported; however, snapshot saving and demo recording are only\r\n    possible in the native ep128emu format\r\n\r\nAmstrad CPC emulation\r\n---------------------\r\n\r\n  * instruction based emulation of the Z80 CPU, supports all documented\r\n    and undocumented opcodes, and cycle accurate synchronization with\r\n    the CRTC and gate array when accessing video memory and I/O ports\r\n  * RAM size can be 64, 128, 192, 320, or 576 kilobytes\r\n  * ROM can be loaded from external image files to the lower ROM and\r\n    expansion ROMs 0 to 7\r\n  * 6845 CRTC (currently type 0 only), gate array, AY-3-8912, 8255 PPI\r\n    (modes 1 and 2 are not supported yet), keyboard, and joystick\r\n    emulation\r\n  * tape emulation with playback, recording, and setting tape position;\r\n    markers can be created for quick positioning to specific tape\r\n    locations (useful for tapes with multiple files); uses custom file\r\n    format which is PCM audio data with 1 to 8 bits of sample resolution\r\n    and variable sample rate, and header including the table of markers;\r\n    there is also read-write (although without markers) support for\r\n    sound files like WAV, AIFF, etc.\r\n  * CPC tape files in .cdt (same as Spectrum .tzx) format can be used as\r\n    tape images for read-only hardware level tape emulation, although\r\n    the support for this format is not complete yet\r\n  * uPD765 (floppy drive controller) emulation; it supports standard and\r\n    extended .DSK files, and also access to real disks (not very useful\r\n    in practice, since only PC format disks can be used this way), as\r\n    well as limited emulation of the timing of disk rotation, stepping,\r\n    and data transfers. The FORMAT TRACK (0x0D) command is not\r\n    implemented yet, and some copy protected games and .DSK files with\r\n    unusual track formats may not work correctly\r\n  * loading SNA snapshot files (v1 or v2; v3 is loaded, but the extra\r\n    information about the internal state of the hardware is currently\r\n    ignored) created by other emulators is supported; however, snapshot\r\n    saving and demo recording are only possible in the native ep128emu\r\n    format\r\n\r\nInstallation\r\n============\r\n\r\nLinux\r\n-----\r\n\r\nOn Linux and other POSIX platforms, the emulator is installed from the\r\nsource code, available at the SourceForge download page\r\n  http://sourceforge.net/project/showfiles.php?group_id=128766\r\nor the most recent state of the code can be downloaded from CVS with the\r\nfollowing command:\r\n  cvs -z3 -d                                                        \\\r\n  :pserver:anonymous@ep128emu.cvs.sourceforge.net:/cvsroot/ep128emu \\\r\n  checkout -P ep128emu2\r\nIn addition to the standard development tools (a recent version of the\r\nGNU C/C++ compiler, binutils, etc.), you need the following packages:\r\n\r\n  * SCons (http://www.scons.org/)\r\n  * Python interpreter for running SCons\r\n  * FLTK 1.1.x (http://www.fltk.org/software.php?VERSION=1.1.10)\r\n    NOTES:\r\n      * this library should be compiled with the --enable-threads\r\n        'configure' option - many Linux distributions include binaries\r\n        of the FLTK library built without --enable-threads, so you may\r\n        need to compile it from sources\r\n      * on MacOS X, FLTK 1.1.7 needs to be patched with the included\r\n        fltk-1.1.7-MacOSX.patch file\r\n  * PortAudio (http://www.portaudio.com/download.html), version 18 and\r\n    19 are supported, but v19 is recommended\r\n  * libsndfile (http://www.mega-nerd.com/libsndfile/#Download)\r\n  * dotconf (version 1.0.13 from http://www.azzit.de/dotconf/, or 1.3\r\n    from https://github.com/williamh/dotconf/archives/master - the\r\n    latter was not tested yet) (optional, but recommended as it is used\r\n    for reading ASCII format configuration files)\r\n  * SDL (http://www.libsdl.org/) 1.2 for joystick input (optional);\r\n    NOTE: on Linux, version 1.2.10 and newer do not work, so using 1.2.9\r\n    is recommended\r\n  * Lua (http://www.lua.org/ or http://www.luajit.org/) for scripting in\r\n    the debugger (optional); version 5.1 is recommended, but 5.0 is also\r\n    supported\r\n\r\nOnce these are installed, you can edit the file 'SConstruct' in the top\r\nlevel source directory for setting compiler flags etc., and run the\r\ncommand 'scons' for building the emulator. The resulting executable\r\nfiles (ep128emu and tapeedit) can be copied to any directory that is in\r\nthe PATH; on MacOS X, an .app package is created in 'ep128emu.app'.\r\nWhen installing the first time, you also need to set up configuration\r\nfiles and ROM images:\r\n\r\n  * download\r\n    http://ep128emu.enterpriseforever.com/roms/ep128emu_roms.bin,\r\n    and copy it to ~/.ep128emu/roms (or, in the case of MacOS X,\r\n    ~/Library/Application Support/ep128emu/roms)\r\n  * after installing the ROM package, run 'makecfg', and click OK to the\r\n    windows that pop up asking for the base directory of configuration\r\n    and data files, and if configuration files should be installed\r\n\r\nIt is possible to reinstall configuration files later by running the\r\n'makecfg' utility.\r\n\r\nWindows\r\n-------\r\n\r\nA binary package with an installer is available at the SourceForge\r\ndownload page:\r\n  http://sourceforge.net/project/showfiles.php?group_id=128766\r\nTo install, just run the executable, and follow the instructions.\r\nThe installer can automatically download the ROM images needed for\r\nrunning the emulator, but these can also be installed manually by\r\ndownloading http://ep128emu.enterpriseforever.com/roms/ep128emu_roms.7z,\r\nand extracting it to roms\\ under the selected installation folder.\r\nWhen asked if configuration files should be reinstalled, click 'OK'\r\nwhen installing the first time, but this step can be skipped in later\r\ninstallations to preserve the configuration.\r\n\r\nWARNING: on Windows, there may be timing problems when using some dual\r\ncore CPUs, or power management features that change the clock frequency\r\nof the CPU while the emulator is running. These issues can result in\r\nslow or erratic emulation speed, not running at 100% speed in real-time\r\nmode, or temporary lockups. If you encounter such problems, forcing the\r\nemulator to run on a single core (by setting the CPU affinity for\r\nep128emu.exe), and/or disabling dynamic changes to the CPU clock\r\nfrequency by power management could fix the timing issues. Installing\r\nand using an utility like AMD Dual Core Optimizer may also solve the\r\nproblem.\r\nNote that bad emulation performance might also be caused by display or\r\naudio drivers, so it is recommended to check (and upgrade, if necessary)\r\nthose as well.\r\n\r\nUsage\r\n=====\r\n\r\nCommand line options\r\n--------------------\r\n\r\n  -h\r\n  -help\r\n  --help\r\n    print the list of available command line options\r\n  -ep128\r\n  -zx\r\n  -cpc\r\n    select the type of machine (Enterprise, ZX Spectrum, or CPC) to be\r\n    emulated\r\n  -cfg <FILENAME>\r\n    load an ASCII format configuration file on startup, and apply\r\n    settings\r\n  -snapshot <FILENAME>\r\n    load snapshot or demo file on startup\r\n  -opengl\r\n    use OpenGL video driver (this is the default, and is recommended\r\n    when hardware accelerated OpenGL is available)\r\n  -no-opengl\r\n    use software video driver; this is slower than OpenGL when used at\r\n    high resolutions, and also disables many display effects, but should\r\n    work on all machines; however, it will use a color depth of 24 bits,\r\n    while in OpenGL mode the textures are 16 bit (R5G6B5) only, to\r\n    improve performance\r\n  -colorscheme <N>\r\n    select GUI color scheme N (0, 1, 2, or 3)\r\n  OPTION=VALUE\r\n    set configuration variable 'OPTION' to 'VALUE'; the available\r\n    variable names are the same as those used in ASCII format\r\n    configuration files\r\n  OPTION\r\n    set boolean configuration variable 'OPTION' to true\r\n\r\n'File' menu\r\n-----------\r\n\r\nConfiguration / Load from ASCII file (Alt + Q)\r\n\r\n  Select and load an ASCII format configuration file and apply the new\r\n  settings. If the configuration file does not include all the supported\r\n  options, those that are omitted are left unchanged.\r\n\r\nConfiguration / Load from binary file (Alt + L)\r\n\r\n  Load an ep128emu format binary file, which may be a previously saved\r\n  snapshot, demo, or a binary format configuration file.\r\n\r\nConfiguration / Save as ASCII file\r\n\r\n  Save the current emulator configuration to an ASCII text file, which\r\n  can be edited with any text editor, and can be loaded at a later time.\r\n\r\nConfiguration / Save\r\n\r\n  Save the current emulator configuration in binary format to the\r\n  default file (~/.ep128emu/ep128cfg.dat). This is also automatically\r\n  done when exiting the emulator.\r\n\r\nConfiguration / Revert\r\n\r\n  Reload emulator configuration from ~/.ep128emu/ep128cfg.dat, and apply\r\n  the original settings.\r\n\r\nSave snapshot (Alt + S)\r\n\r\n  Save a snapshot of the current state of the emulated machine to the\r\n  selected file. The snapshot will also include the current memory\r\n  configuration and ROM images, but clock frequency and timing settings\r\n  are not restored when loading a snapshot. The file format may be\r\n  subject to changes between different releases of the emulator. Note\r\n  that the state of any disk drives is currently not saved, and the\r\n  drives are reset on loading a snapshot.\r\n\r\nLoad snapshot (Alt + L)\r\n\r\n  Load an ep128emu format binary file, which may be a previously saved\r\n  snapshot, demo, or a binary format configuration file.\r\n\r\nQuick snapshot / Set file name\r\n\r\n  Select file name for quick snapshots. The default is\r\n  ~/.ep128emu/qs_ep128.dat. This setting is not saved on exit.\r\n\r\nQuick snapshot / Save (Ctrl + F9)\r\n\r\n  Save snapshot to the quick snapshot file (see notes above).\r\n\r\nQuick snapshot / Load (Ctrl + F10)\r\n\r\n  Load the quick snapshot file if it exists.\r\n\r\nRecord demo\r\n\r\n  Save snapshot (including clock frequency and timing settings) and\r\n  record keyboard events to the selected file until the recording is\r\n  stopped. The events can be replayed with accurate timing when the\r\n  file is loaded later. Note that the file format may change between\r\n  different releases of the emulator, and the timing may also be\r\n  incorrect when using a different version to play a demo file.\r\n\r\nStop demo (Alt + K)\r\n\r\n  Stop any currently running demo playback or recording.\r\n\r\nLoad demo (Alt + L)\r\n\r\n  Load an ep128emu format binary file, which may be a previously saved\r\n  snapshot, demo, or a binary format configuration file.\r\n\r\nRecord audio / Start...\r\n\r\n  Write 16 bit signed PCM sound output to a WAV format sound file.\r\n\r\nRecord audio / Stop\r\n\r\n  Close sound output file if it is currently being written.\r\n\r\nRecord video / Start...\r\n\r\n  Open new AVI file for video recording. This increases the CPU usage\r\n  significantly, and since the data is written without compression, it\r\n  will take up a lot of disk space. If the size of the output file\r\n  reaches 2 GB, it is automatically closed, and the emulator asks for\r\n  a new file to continue the recording.\r\n  NOTE: the video and audio streams in the AVI file are not affected by\r\n  any of the display or sound configuration settings.\r\n\r\nRecord video / Stop\r\n\r\n  Stop video capture, and close any AVI file that is currently being\r\n  written.\r\n\r\nSave screenshot (F12, Alt + C)\r\n\r\n  Save a screenshot in 8 bit RLE compressed BMP format. The video output\r\n  is captured immediately after activating this menu item, and is saved\r\n  at a resolution of 768x576 without any processing (color correction,\r\n  effects, etc.).\r\n\r\nQuit (Shift + F12)\r\n\r\n  Exit the emulator.\r\n\r\n'Machine' menu\r\n--------------\r\n\r\nReset / Reset (F11)\r\n\r\n  This has the same effect as using the reset button on the real\r\n  machine.\r\n\r\nReset / Force reset (Ctrl + F11)\r\n\r\n  In addition to a normal reset, make sure that the emulated machine is\r\n  really restarted using the standard ROM reset routines, and do not\r\n  allow programs to disable reset by setting custom (RAM) handlers.\r\n\r\nReset / Reset clock frequencies\r\n\r\n  Reset clock frequency and timing settings to those specified in the\r\n  machine configuration; this is normally only useful after demo\r\n  playback, which may override the settings.\r\n\r\nReset / Reset machine configuration (Shift + F11)\r\n\r\n  Reset memory configuration (RAM size, ROM images), clock frequency,\r\n  and timing settings according to the machine configuration, and clear\r\n  all RAM data. Implies 'Force reset' and 'Reset clock frequencies'.\r\n  Reverting the configuration can be useful after snapshot loading or\r\n  demo playback, as these may change the settings.\r\n\r\nQuick configuration / Load config 1 (PageDown)\r\n\r\n  Load the configuration file ~/.ep128emu/epvmcfg1.cfg, and apply the\r\n  new settings.\r\n\r\nQuick configuration / Load config 2 (PageUp)\r\n\r\n  Load the configuration file ~/.ep128emu/epvmcfg2.cfg, and apply the\r\n  new settings.\r\n\r\nQuick configuration / Save config 1\r\n\r\n  Save the current clock frequency and timing settings to\r\n  ~/.ep128emu/epvmcfg1.cfg.\r\n\r\nQuick configuration / Save config 2\r\n\r\n  Save the current clock frequency and timing settings to\r\n  ~/.ep128emu/epvmcfg2.cfg.\r\n\r\n'Options' menu\r\n--------------\r\n\r\nDisplay / Set size to 384x288\r\nDisplay / Set size to 768x576\r\nDisplay / Set size to 1152x864\r\n\r\n  Resize the emulator window to predefined width/height values; this has\r\n  no effect in fullscreen mode. While the window can also be resized\r\n  using the window manager, sizes that are integer multiples of the\r\n  actual screen resolution of the emulated machine may look better,\r\n  particularly when texture filtering is not used, and are also slightly\r\n  faster when using the software video driver.\r\n\r\nDisplay / Cycle display mode (F9)\r\n\r\n  Cycle between these four display modes:\r\n    window with no menu bar\r\n    window with menu bar (this is the default)\r\n    fullscreen with menu bar\r\n    fullscreen with no menu bar\r\n\r\nSound / Increase volume\r\n\r\n  Increase sound output volume by about 2 dB.\r\n\r\nSound / Decrease volume\r\n\r\n  Decrease sound output volume by about 2 dB.\r\n\r\nDisk / Configure... (Alt + D)\r\n\r\n  Opens a dialog for setting up floppy and IDE emulation.\r\n\r\n  For each floppy drive, an image file can be selected, and disk\r\n  geometry parameters can be specified. If the file name is left empty,\r\n  that means having no disk in that particular drive. It may also be\r\n  possible to directly access a real disk by using the /dev/fd* devices\r\n  (on Linux) or \\\\.\\A: (on Windows) as the image file.\r\n  Any of the geometry parameters can be zero or negative to have the\r\n  value calculated automatically from the others (if available), the\r\n  image file size, and the file system header.\r\n\r\n  The IDE emulation supports image files in raw and VHD format (the\r\n  latter must have a .vhd extension), with a file size of up to 2 GB.\r\n  In the case of VHD files, the disk geometry is determined by the VHD\r\n  footer, while the geometry of raw images is calculated from the file\r\n  size. Depending on the image format, the model number string of the\r\n  emulated drive will include \"(VHD)\" or the automatically assigned\r\n  geometry.\r\n  The emulator package includes a 126 MB VHD format IDE disk image in\r\n  disk/ide126m.vhd.bz2, with 4 FAT12 formatted 31.5 MB partitions.\r\n  Note that with the current version of IDE.ROM, after changing IDE disk\r\n  images, a cold reset is required for the changes to be detected, and\r\n  the disk change flag is also set on snapshot or demo loading.\r\n\r\n  Floppy and IDE drives are disabled while recording or playing a demo.\r\n\r\nDisk / Remove floppy / Drive A\r\nDisk / Remove floppy / Drive B\r\nDisk / Remove floppy / Drive C\r\nDisk / Remove floppy / Drive D\r\nDisk / Remove floppy / All drives\r\n\r\n  These are just shortcuts for setting the image file name for a\r\n  specific floppy drive to an empty string.\r\n\r\nDisk / Replace floppy / Drive A (Alt + H)\r\nDisk / Replace floppy / Drive B\r\nDisk / Replace floppy / Drive C\r\nDisk / Replace floppy / Drive D\r\nDisk / Replace floppy / All drives\r\n\r\n  Set the image file name for a specific (or all) floppy drive to an\r\n  empty string, and then set the original file name again. This is\r\n  mostly useful when accessing real floppy disks, and should be used\r\n  after the disk is changed.\r\n\r\nSet working directory (Alt + F)\r\n\r\n  Set the directory to be accessed by the optional file I/O ROM\r\n  extension modules.\r\n\r\nMemory configuration files\r\n--------------------------\r\n\r\nWhile the GUI based memory configuration is easy to use, and is\r\nsufficient for creating the most commonly used configurations, it does\r\nhave a number of limitations. Using a configuration file - which is a\r\nsimple text file with a format described below - makes it possible to\r\nhave RAM, ROM, or no memory at any segment, and image files can also be\r\nloaded to RAM (e.g. for emulating static RAM).\r\nNOTE: if a memory configuration file is specified, the RAM/ROM settings\r\nin the \"Machine configuration\" GUI are ignored.\r\n\r\nA memory configuration file may contain any number of segment range\r\ndefinitions, each being a line in one of the following formats for RAM\r\nor ROM:\r\n  0xNN RAM \"fileName\" nSegments\r\n  0xNN ROM \"fileName\" nSegments\r\nwhere 'NN' is the number of the first segment (hexadecimal), 'fileName'\r\nis the name of the file to be loaded (with full path; backslash or\r\ndouble quote characters in the name should be escaped with a backslash),\r\nand 'nSegments' is the number of segments to be defined as RAM or ROM\r\n(decimal). If 'nSegments' is not specified, then it defaults to 1 for an\r\nempty file name, otherwise it is determined by the size of the image\r\nfile. If 'fileName' is also omitted, then it means a single empty\r\nsegment.\r\nThe configuration file may also include comments and empty lines.\r\nA comment can begin with the semicolon or '#' character, and the rest of\r\nthe line is ignored.\r\nUnlike images loaded in the GUI ROM configuration, it is not necessary\r\nfor the files to have a size that is an integer multiple of 16384 bytes:\r\nthe last segment is padded with FFh bytes. An empty file name will\r\ninitialize RAM segments to FFh bytes, while in the case of ROM, it means\r\nthat the segments will be empty. If the file is longer than the size\r\ndefined by 'nSegments', the data is truncated; if it is too short, then\r\nthe segments are repeated.\r\nBy default, segments 00h..FBh are empty, and FCh..FFh are RAM. The type\r\nof the last four segments (the video memory) cannot be changed to ROM.\r\n\r\nA simple example file, assuming that the emulator is installed to\r\n\"C:\\Program Files\\ep128emu2\":\r\n\r\n  ; EXOS 2.1 at segments 0, 1 (and repeated at segments 2, 3)\r\n  0x00 ROM \"C:\\\\Program Files\\\\ep128emu2\\\\roms\\\\exos21.rom\" 4\r\n  ; IS-BASIC 2.1 at segment 4\r\n  0x04 ROM \"C:\\\\Program Files\\\\ep128emu2\\\\roms\\\\basic21.rom\"\r\n  ; 128K RAM at segments F8h..FFh\r\n  0xF8 RAM \"\" 8\r\n\r\nReading I/O ports in the debugger\r\n---------------------------------\r\n\r\nWrite-only I/O ports are readable in the monitor and Lua scripts, and\r\nreturn the last value written to the port. There are also some changes\r\nto the address decoding compared to what is seen by the emulated Z80\r\ncode, depending on the machine type:\r\n  - Spectrum:\r\n    - below port address 20H, the Kempston joystick state is read from\r\n      all addresses\r\n    - the last value written to the ULA is read from any other even\r\n      address that is less than 100H\r\n    - in Spectrum 128 mode, if the address is less than 100H, and the\r\n      lowest two bits are 01B, the memory paging register is returned\r\n    - reading any other I/O port below 100H returns FFH\r\n    - reading from ports 0xxxxxxxxxxxxx0xB does not write the data bus\r\n      state to the memory paging register\r\n  - CPC:\r\n    - when reading the gate array/RAM configuration port, the function\r\n      (pen/color/video mode/memory configuration) can be selected in\r\n      bits 6 and 7 of the address; for example, reading port 7F40H\r\n      returns the color of the currently selected pen\r\n    - in the address range 0 to 9FH, many I/O registers can be read\r\n      directly:\r\n      - 00H-1FH: 6845 CRTC registers\r\n      - 20H-2FH: gate array palette\r\n      - 30H-3FH: gate array border color\r\n      - 40H-4FH: AY-3-8912 registers\r\n      - 50H-5FH: 8255 PPI registers\r\n          0101x000B: port A current state (input or output)\r\n          0101x001B: port B current state (input or output)\r\n          0101x010B: port C current state (input or output)\r\n          0101xx11B: control register\r\n          0101x100B: last value written to port A register\r\n          0101x101B: last value written to port B register\r\n          0101x110B: last value written to port C register\r\n      - 60H-6FH: keyboard matrix state\r\n      - 70H:     currently selected CRTC register\r\n      - 71H:     CRTC flags\r\n          bit 0: 1 if the \"display enabled\" output is active\r\n          bit 1: 1 if the HSYNC output is active\r\n          bit 2: 1 if the VSYNC output is active\r\n          bit 3: 1 if the current field is odd in interlaced modes\r\n          bit 4: 1 if the \"cursor enabled\" output is active\r\n      - 72H:     current video memory address / low\r\n      - 73H:     current video memory address / high\r\n      - 74H:     video mode (0 to 3)\r\n      - 75H:     currently selected pen number\r\n      - 76H:     gate array IRQ counter (0 to 51)\r\n      - 77H:     AY-3-8912 register selected\r\n      - 78H:     RAM configuration (bits 6 and 7 are RAM enable flags\r\n                 for page 0 and page 3)\r\n      - 79H:     currently selected expansion ROM bank\r\n      - 7AH-7FH: unused, FFH is returned\r\n      - 80H-9FH: uPD765 floppy drive controller registers and state\r\n          80H: FDC phase (0: idle, 1: command, 2: execution, 3: result)\r\n          81H: last command code\r\n          82H: motor state (last byte written to 0FA7EH & 01H)\r\n          83H: currently selected physical head (0 or 1) * 4 + drive\r\n          84H: CPU<->FDC data transfer position LSB\r\n          85H: CPU<->FDC data transfer position MSB\r\n          86H: CPU<->FDC data transfer size LSB\r\n          87H: CPU<->FDC data transfer size MSB\r\n          88H: logical cylinder ID\r\n          89H: logical head ID\r\n          8AH: logical sector ID\r\n          8BH: sector size code\r\n          8CH: last sector ID (EOT), or sector count for format track\r\n          8DH: gap length\r\n          8EH: sector data length (DTL), or STP for scan commands\r\n          8FH: filler byte (format track only)\r\n          90H: first byte in command/data/result buffer\r\n          91H: second byte in command/data/result buffer\r\n          92H: third byte in command/data/result buffer\r\n          93H: fourth byte in command/data/result buffer\r\n          94H: ST1 for read/write commands\r\n          95H: ST2 for read/write commands\r\n          96H: specify parameter 1 (step rate / head unload time)\r\n          97H: specify parameter 2 (head load time)\r\n          98H: ST3 for sense drive status on drive 0\r\n          99H: ST3 for sense drive status on drive 1\r\n          9AH: ST3 for sense drive status on drive 2\r\n          9BH: ST3 for sense drive status on drive 3\r\n          9CH: drive 0 cylinder number (PCN0)\r\n          9DH: drive 1 cylinder number (PCN1)\r\n          9EH: drive 2 cylinder number (PCN2)\r\n          9FH: drive 3 cylinder number (PCN3)\r\n    - unlike the other machine types, I/O watchpoints are set on the\r\n      upper 8 bits of the address\r\n\r\nLua scripting\r\n-------------\r\n\r\nStarting from version 2.0.5, it is possible to run scripts written in\r\nLua from the debugger. This document only describes the use of scripts\r\nin the emulator, and the new API functions added; for general\r\ninformation about programming in Lua, see http://www.lua.org/docs.html\r\n\r\nClicking the 'Run' button will run the script, and also enable the\r\nbreakpoint callback function (see below) if it is defined. If there are\r\nany syntax or runtime errors, the script is terminated, and the\r\nbreakpoint callback is disabled. After making any changes to the script,\r\nyou need to click 'Run' and restart the script for the changes to take\r\neffect.\r\n\r\nIt is possible to define a breakpoint callback function in the script,\r\nwhich will be automatically called whenever a breakpoint is triggered,\r\nand the debugger window would be shown. This function has the following\r\nsyntax:\r\n\r\n  function breakPointCallback(bpType, addr, value)\r\n    ...\r\n    return showWindow\r\n  end\r\n\r\nwhere 'showWindow' is a boolean value, which, if true, will allow the\r\ndebugger window to be shown like normal, or have the emulated program\r\ncontinue without any break if it is false. The four parameters passed to\r\nthe function are as follows:\r\n\r\n  bpType\r\n\r\n    The type of break, one of the following:\r\n      0: breakpoint at opcode read by the CPU\r\n      1: data read from memory\r\n      2: data written to memory\r\n      3: opcode read in single step mode; this happens when 'Step' or\r\n         'Step over' are being used, and if the breakpoint callback\r\n         function returns false, breaks will continue to occur until\r\n         true is returned\r\n      5: I/O port read\r\n      6: I/O port write\r\n\r\n  addr\r\n\r\n    This is the 16 bit address where the break occured.\r\n\r\n  value\r\n\r\n    The value or CPU opcode read from or written to memory or I/O port.\r\n\r\nThe breakpoint callback function will remain active until either a new\r\nscript is run which does not define one, or the 'Stop' button is\r\nclicked.\r\n\r\nNOTE: an infinite loop in the script will hang the emulator, and a very\r\nfrequently called and/or complex breakpoint callback may slow down the\r\nemulation.\r\n\r\nThe following new functions are defined by the emulator for use in the\r\nscripts:\r\n\r\n  AND(...)    OR(...)    XOR(...)    SHL(a, b)    SHR(a, b)\r\n\r\n    These simple helper functions implement bitwise operations that are\r\n    not available in the Lua language by default.\r\n    AND, OR, and XOR can take any number of integer arguments, and\r\n    return the bitwise AND, OR, and XOR of the values, respectively. In\r\n    the case of zero arguments, OR and XOR return zero, while AND\r\n    returns -1.\r\n    SHL returns 'a' shifted to the left by 'b' bits, and SHR returns 'a'\r\n    shifted to the right by 'b' bits. If 'b' is zero, the value is not\r\n    changed, while a negative 'b' will reverse the direction of\r\n    shifting. The result of shifting negative values to the right is\r\n    unspecified.\r\n\r\n  setBreakPoint(bptype, addr, priority)\r\n\r\n    Set a breakpoint or watchpoint at address 'addr' (0-0xFFFF), with\r\n    priority 'priority' (0 to 3). 'bptype' can be one of the following\r\n    values:\r\n\r\n      0: any memory access (read, write, or Z80 opcode read)\r\n      1: memory read\r\n      2: memory write\r\n      3: any memory access, same as bptype == 0\r\n      4: Z80 opcode read\r\n      5: I/O port read\r\n      6: I/O port write\r\n      7: I/O port read or write\r\n\r\n    For memory breakpoints, it is possible to add 8 to 'bpType' to\r\n    interpret the address as a 22 bit value in the range 0 to 0x3FFFFF,\r\n    with the segment number determined by the most significant 8 bits.\r\n    If the address is greater than 0xFFFF, it is also automatically\r\n    assumed to be in 22 bit format.\r\n    An \"ignore\" breakpoint can be defined by adding 16 to 'bpType', this\r\n    will disable other breakpoints when the program counter is at the\r\n    address to be ignored. It is still possible to have a normal read or\r\n    write breakpoint as well at the same address, by setting the lowest\r\n    three bits of 'bpType' to 1, 2, or 3.\r\n    A 'priority' value of -1 will delete an existing breakpoint at the\r\n    specified address.\r\n    The read, write, execute, and ignore flags are combined (bitwise OR)\r\n    if multiple breakpoints are set at the same address, while the\r\n    priority will be the highest value specified.\r\n\r\n    NOTE: the changes made to the breakpoint list by the script are not\r\n    reflected in the breakpoint editor. To restore the previously\r\n    defined breakpoints, click the 'Apply' button.\r\n\r\n  clearBreakPoints()\r\n\r\n    Deletes all previously defined breakpoints.\r\n\r\n  getMemoryPage(n)\r\n\r\n    Returns the segment selected for page 'n' (0 to 3).\r\n    In Spectrum or CPC emulation mode, RAM is mapped starting from\r\n    segment 00H. For the CPC, segments 00H to 03H are the internal RAM,\r\n    the lower ROM is at segment 80H, and expansion ROM 'n' is at segment\r\n    C0H + 'n'; this function returns the number of the segment for read\r\n    access (i.e. ROM if it is enabled). In the case of ZX Spectrum, the\r\n    ROM is at segment 80H (Spectrum 16 and 48), or segments 80H and 81H\r\n    (Spectrum 128).\r\n\r\n  readMemory(addr)\r\n\r\n    Read a byte from 'addr' (0 to 0xFFFF) in the address space of the\r\n    CPU.\r\n\r\n  writeMemory(addr, value)\r\n\r\n    Write 'value' to 'addr' (0 to 0xFFFF) in the address space of the\r\n    CPU.\r\n\r\n  readMemoryRaw(addr)\r\n\r\n    Read a byte from 'addr' (0 to 0x3FFFFF) in the \"physical\" address\r\n    space; the most significant 8 bits of 'addr' select the segment\r\n    number.\r\n\r\n  writeMemoryRaw(addr, value)\r\n\r\n    Write 'value' to 'addr' (0 to 0x3FFFFF) in the \"physical\" address\r\n    space; the most significant 8 bits of 'addr' select the segment\r\n    number.\r\n\r\n  readWord(addr)\r\n  writeWord(addr, value)\r\n  readWordRaw(addr)\r\n  writeWordRaw(addr, value)\r\n\r\n    These are similar to the memory read/write functions above, but read\r\n    and write 16-bit LSB-first words instead of single bytes.\r\n\r\n  readIOPort(addr)\r\n\r\n    Read a byte from I/O port 'addr' (0 to 0xFFFF).\r\n\r\n  writeIOPort(addr, value)\r\n\r\n    Write 'value' to I/O port 'addr' (0 to 0xFFFF).\r\n\r\n  getPC()    getA()     getF()     getAF()    getB()     getC()\r\n  getBC()    getD()     getE()     getDE()    getH()     getL()\r\n  getHL()    getSP()    getIX()    getIY()    getAF_()   getBC_()\r\n  getDE_()   getHL_()   getIM()    getI()     getR()     getIFF1()\r\n  getIFF2()\r\n\r\n    These functions return the registers of the CPU.\r\n\r\n  setPC(n)   setA(n)    setF(n)    setAF(n)   setB(n)    setC(n)\r\n  setBC(n)   setD(n)    setE(n)    setDE(n)   setH(n)    setL(n)\r\n  setHL(n)   setSP(n)   setIX(n)   setIY(n)   setAF_(n)  setBC_(n)\r\n  setDE_(n)  setHL_(n)  setIM(n)   setI(n)    setR(n)    setIFF1(n)\r\n  setIFF2(n)\r\n\r\n    Set CPU registers. Note that changing the program counter only takes\r\n    effect after the execution of one instruction is completed.\r\n\r\n  getNextOpcodeAddr(addr[, cpuAddressMode])\r\n\r\n    Returns the address of the next Z80 instruction after the\r\n    instruction at 'addr'. 'cpuAddressMode' selects the use of 16 bit\r\n    CPU (if true or not specified) or 22 bit physical (if false)\r\n    addresses.\r\n\r\n  getVideoPosition()\r\n\r\n    Returns the current video position as two values (horizontal and\r\n    vertical).\r\n\r\n    In the case of Spectrum emulation, both values are in pixels, in the\r\n    range 0 to 447 and 0 to 311 for the Spectrum 48, or 0 to 455 and 0\r\n    to 310 for the Spectrum 128.\r\n    The upper left corner of the screen is at 0,0 (it is the cycle when\r\n    the byte read from 4000H appears on the floating bus), and the lower\r\n    right corner is at 255,191.\r\n    The line number is incremented 64 pixels before X=0 (X=384 or X=392\r\n    in 48K or 128K mode, respectively), but this may possibly change in\r\n    future versions.\r\n\r\n    For the Enterprise, the horizontal position is in characters, in the\r\n    range 0 to 56. The vertical position is the sum of the 8-bit line\r\n    counter within the current line parameter block (LPB), which counts\r\n    up to 255, and the video memory address of the LPB multiplied by 16.\r\n\r\n    In CPC emulation mode, the horizontal position is in characters, and\r\n    the vertical position is in raster lines, i.e. 0 to 63 and 0 to 311\r\n    with the default CRTC settings. Position 0,0 is the upper left\r\n    corner of the screen, this is the CRTC cycle when the first two\r\n    bytes of the screen memory are read. In the case of interlaced video\r\n    mode (CRTC register 8 = 3), the vertical position is in frame lines,\r\n    and is incremented by two each line (it is even or odd depending on\r\n    the current field).\r\n\r\n  getRawAddress(segment, offset)\r\n\r\n    Calculates a 22-bit physical address from the specified segment and\r\n    offset; only the 14 least significant bits of 'offset' are used.\r\n\r\n  getRawAddress(addr)\r\n\r\n    Calculates a 22-bit physical address from a 16-bit CPU address,\r\n    using the current memory paging.\r\n\r\n  loadMemory(fname, asciiMode, cpuAddressMode, startAddr[, endAddr])\r\n\r\n    Loads a file to the memory area at 'startAddr' to 'endAddr' (the\r\n    byte at 'endAddr' is still loaded). If no end address is specified,\r\n    all data is read into memory. The file is searched in the working\r\n    directory set for file I/O, and if the name is an empty string, a\r\n    file selection dialog is shown. The expected file format is binary\r\n    if 'asciiMode' is false, and hexadecimal dump (as written by\r\n    saveMemory() or the 'S' monitor command) if 'asciiMode' is true.\r\n    'cpuAddressMode' selects the use of 16 bit CPU (if true) or 22 bit\r\n    physical (if false) addresses.\r\n    The return value is the number of bytes actually read.\r\n\r\n  saveMemory(fname, asciiMode, cpuAddressMode, startAddr, endAddr)\r\n\r\n    Save the memory area at 'startAddr' to 'endAddr' (the byte at\r\n    'endAddr' is still written) to a file, in binary (if 'asciiMode' is\r\n    false) or hexadecimal dump (if 'asciiMode' is true) format.\r\n    'cpuAddressMode' selects the use of 16 bit CPU (if true) or 22 bit\r\n    physical (if false) addresses.\r\n\r\n  mprint(...)\r\n\r\n    Prints any number of strings or numbers to the monitor.\r\n    No separator characters are inserted between the arguments being\r\n    printed, and a newline character is automatically added at the end\r\n    of the message.\r\n\r\nExample:\r\n\r\n  mprint(\"Running Lua script example...\")\r\n  clearBreakPoints()\r\n  setBreakPoint(4, 0x0040, 2)   -- break on reading Z80 opcode at 0x0040\r\n  function breakPointCallback(t, a, v)\r\n    if t == 3 then              -- allow stepping\r\n      return true\r\n    end\r\n    -- check for EXOS 1 call with A=102\r\n    if getPC() ~= 0x0040 or getA() ~= 1 or readMemory(0x005A) ~= 102 then\r\n      return false\r\n    end\r\n    -- read name parameter from memory\r\n    s = \"\"\r\n    n = readMemory(getDE())\r\n    for i = 1, n do\r\n      s = s..string.char(readMemory(getDE() + i))\r\n    end\r\n    mprint(\"Channel #102 is opened with name '\", s, \"'\")\r\n    return true\r\n  end\r\n  mprint(\"done.\")\r\n\r\nThis will break when channel 102 is opened, and print the name parameter\r\npassed to the EXOS call.\r\n\r\n------------------------------------------------------------------------\r\n\r\nCopyright\r\n=========\r\n\r\nep128emu is copyright (C) 2003-2010 by Istvan Varga\r\n<istvanv@users.sourceforge.net>. Z80 emulation copyright (C) 1999-2003\r\nby Kevin Thacker and Vincze Béla György.\r\n\r\nThis program is free software; you can redistribute it and/or modify it\r\nunder the terms of the GNU General Public License as published by the\r\nFree Software Foundation; either version 2 of the License, or (at your\r\noption) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful, but\r\nWITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\nGeneral Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License along\r\nwith this program; if not, write to the Free Software Foundation, Inc.,\r\n59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\r\n\r\nCredits\r\n-------\r\n\r\nThanks to:\r\n\r\nZozosoft      - hardware testing and information\r\nMrPrise       - ep128emu.enterpriseforever.com web site\r\nAttus         - Linux binary packages\r\nMartin Bantz  - PCLinuxOS RPM spec file\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}